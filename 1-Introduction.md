## 1. Introduction

本章首先激发了对分布式编程抽象的需求。 特别关注抽象，这些抽象捕获了分布式系统中多个进程之间强大的协作形式的基础问题，通常称为协议抽象。 然后，本章提出了一种模块化策略，通过特定的应用程序编程接口（API）利用这些抽象来开发分布式程序。

还给出了一个简单，具体的API示例，以说明本书中使用的符号和基于事件的调用方案来描述实现我们抽象的算法。 符号和调用方案非常接近于分布式算法的实际实现中的那些。

### 1.1 Motivation

分布式计算为寻求实现某种形式的合作的一组过程寻址算法。 除了并发执行外，分布式系统的某些进程可能会停止运行，例如，崩溃或断开连接，而其他进程可能会保持活动并继续运行。 这种部分故障的概念是分布式系统的特征。 事实上，如果真的觉得需要区分分布式系统和并发系统，这个概念会很有用。 这是为了引用Leslie Lamport：

> “分布式系统是指你甚至不知道存在的计算机故障会使您自己的计算机无法使用的系统。”

当进程的子集发生故障或断开连接时，挑战通常是仍在运行或连接到大多数进程的进程，以便以一致的方式同步其活动。换句话说，必须使合作变得强大，以容忍部分失败，有时还能抵抗对抗性攻击。这使得分布式计算成为一个艰难但极其刺激的问题。由于进程的异步性，通信基础设施中出现故障的可能性，甚至可能是故障进程的恶意操作，因此可能无法准确地检测到进程故障;特别是，通常无法区分过程失败和网络故障，我们将在本书后面详细讨论。更糟糕的是，一个受恶意攻击者控制的进程可能会故意行为不端，以扰乱其余进程之间的通信。这使得确保一致合作的问题变得更加困难。分布式计算的挑战恰恰在于设计算法，这些算法提供的流程保持足够的一致信息，以便他们能够正确合作并解决常见任务。

事实上，我们今天使用的许多程序都是分布式程序。简单的日常例程，例如阅读电子邮件或浏览Web，涉及某种形式的分布式计算。但是，在使用这些应用程序时，我们通常面临最简单的分布式计算形式：客户端 - 服务器计算。在客户端 - 服务器计算中，集中式进程即服务器向许多远程客户端提供服务。客户端和服务器通过交换消息进行通信，通常遵循请求 - 回复形式的交互。例如，为了向用户显示网页，浏览器向Web服务器发送请求并期望获得具有要显示的信息的响应。分布式计算的核心难点，即在存在部分故障的情况下实现一致的合作形式，甚至可以通过使用这种简单的交互形式弹出。回到我们的浏览示例，如果被咨询的Web服务器出现故障（但用户自动切换到另一个Web服务器），则期望用户继续浏览Web是合理的，甚至更合理的是服务器进程继续提供信息到其他客户端进程，即使其中一些进程失败或断开连接。

当分布式计算仅限于双方之间的交互时，例如在客户端 - 服务器情况下，上述问题已经非常重要。但是，分布式计算比处理客户端 - 服务器交互更多。通常，不仅需要两个，而且需要多个流程才能合作并同步其行动以实现共同目标。多个进程的存在使分布式计算更加复杂化。有时我们会讨论这种一般情况下的多方互动。事实上，这两种模式可能以非常自然的方式共存。实际上，许多分布式应用程序具有遵循客户端 - 服务器交互模式的部分以及遵循多方交互模式的其他部分。这甚至可能是一个透视问题。例如，当客户端联系服务器以获取服务时，它可能不知道，为了提供该服务，服务器本身可能需要请求几个其他服务器的帮助，它需要与之协调以满足客户的要求。有时，表达式对等计算用于强调缺少中央服务器。

### 1.2 Distributed Programming Abstractions

就像微笑的行为一样，抽象行为仅限于很少的自然物种。 通过捕获大型系统中常见的属性，抽象有助于区分基础和附件，并防止系统设计人员和工程师一遍又一遍地重新发明相同问题的轻微变体。

From the Basics . . . 关于分布式系统的推理应该从抽象底层物理系统开始：以抽象的方式描述相关元素，识别它们的内在属性，并描述它们的交互，引导我们定义所谓的系统模型。 在本书中，我们将主要使用两个抽象来表示底层物理系统：进程和链接。

分布式程序的过程抽象执行计算的活动实体。 进程可以表示计算机，计算机内的处理器，或者仅代表处理器内的特定执行线程。 在网络安全的上下文中，进程还可以表示信任域，主体或一个管理单元。 为了在一些共同任务上合作，这些过程通常可能需要使用某种通信网络来交换消息。 链接抽象了支持进程间通信的物理和逻辑网络。 通过捕获过程和链接的不同属性，例如，通过描述这些元素在不同环境条件下如何操作或失败，可以表示分布式系统的多个实现。

第2章将深入讨论本书中使用的各种分布式系统模型。

. . . to the Advanced. 给定系统模型，下一步是了解如何构建捕获分布式应用程序中重复交互模式的抽象。 在本书中，我们感兴趣的是抽象，这些抽象可以捕获各组流程之间的强大合作问题，因为这些问题非常重要且具有挑战性。 流程之间的合作有时可以建模为分布式协议问题。 例如，过程可能需要就a是否达成一致 某些事件已经（或没有）发生，就要执行的一系列共同行动（从多个初始备选方案）达成一致，或者通过以下方式达成一致意见： 哪一组输入需要处理。 期望以增量方式从解决方案到更简单的协议问题建立更复杂的协议形式。 例如，考虑以下情况：

- 为了使进程能够交换信息，他们必须首先就他们是谁（例如，使用因特网上的IP地址）以及用于表示消息的一些通用格式达成一致。 他们可能还需要就交换消息的某种方式达成一致（例如，使用可靠的数据流进行通信，例如通过因特网的TCP）。
- 在交换一些消息之后，这些过程可能面临几个备选的行动计划。 他们可能需要在几个备选方案中就共同计划达成共识，并且每个参与流程最初可能有自己的计划，与其他流程的计划不同。
- 在某些情况下，只有当所有其他进程也同意应该采取这样的步骤时，合作过程才可以采取给定步骤。 如果不满足此条件，则所有流程必须同意不应执行该步骤。 这种形式的协议在分布式事务的处理中至关重要，在这种情况下，这个问题被称为原子提交问题。
- 进程可能不仅需要就应执行哪些操作达成一致，还需要就执行这些操作的顺序达成一致。 这种形式的协议是复制计算以实现容错的最基本技术之一的基础，它被称为全序广播问题。

本书是关于掌握构成这些问题的难点，并设计封装这些问题的抽象。 问题很难，因为它们需要在各个过程之间进行协调; 由于流程可能会失败或者甚至可能会恶意行为，因此这种抽象是强大的，有时也不容易构建。 在下文中，我们激发了本书中涉及的一些抽象的相关性。 我们一方面区分抽象出现的情况和应用程序的自然分布，另一方面区分这些抽象作为工程选择的工件的出现。

#### 1.2.1 Inherent Distribution

需要在多个参与者进程之间共享或传播信息的应用程序是出现需要分布式编程抽象的问题的沃土。 这种应用的示例是信息分发引擎，多用户协作系统，分布式共享空间，过程控制系统，协作编辑器，分布式数据库和分布式存储系统。

信息传播。 在具有信息传播要求的分布式应用程序中，流程可以扮演以下角色之一：信息生产者，也称为发布者，或信息消费者，也称为订阅者。 由此产生的交互范例通常称为发布 - 订阅模式。

出版商以通知的形式提供信息。 订阅者注册他们对接收某些通知的兴趣。 存在发布 - 订阅模式的不同变体以将所生成的信息与订户的兴趣相匹配，包括基于频道，基于主题，基于内容或基于类型的订阅。 与订阅方法无关，几个订户很可能对相同的通知感兴趣，系统应该向它们广播。 在这种情况下，我们通常感兴趣的是让相同信息的所有订户接收相同的消息集。 否则系统将提供不公平的服务，因为一些订户可以访问比其他订户更多的信息。

除非底层基础设施免费提供此可靠性属性（通常情况并非如此），否则发送方和订户必须协调以商定应传递哪些消息。 例如，通过传播音频流，过程通常对接收大部分信息感兴趣，但能够容忍有限量的消息丢失，尤其是如果这允许系统实现更好的吞吐量。 相应的抽象通常称为尽力广播。

传播某些证券交易所信息可能需要更可靠的广播形式，称为可靠广播，因为我们希望所有活动过程都能收到相同的信息。 人们甚至可能要求从证券交易所基础设施中以有序的方式传播信息。 在一些发布 - 订阅应用程序中，生产者和消费者在一组中间合作经纪人的支持下间接地进行交互。 在这种情况下，协议抽象可能对经纪人之间的合作有用。

进程控制。 进程控制应用程序是指多个软件过程必须控制物理活动执行的应用程序。 基本上，这些进程更可能是控制飞机或火车的动态位置。 他们也可能控制核装置或自动化的温度 汽车生产厂。

通常，每个进程都连接到某个传感器。 例如，这些进程可能需要交换由其分配的传感器输出的值并输出一些共同的值，例如，在飞行员控制屏幕上打印飞机的单个位置，尽管由于不准确或故障导致 他们的本地传感器，他们可能观察到略微不同的输入值。 尽管一些传感器（或相关的控制过程）已经崩溃或没有观察到任何东西，但应该实现这种合作。 如果所有过程都对控制算法的同一组输入达成一致，则可以简化这种类型的协作，这是共识抽象所捕获的要求。

合作工作。 位于网络的不同节点上的用户可以合作建立公共软件或文档，或者简单地建立分布式对话，例如，用于在线聊天或虚拟会议。 共享工作空间抽象在这里非常有用，可以实现有效的合作。 这种分布式共享存储器抽象通常通过用户的读写操作来访问以存储和交换信息。 在最简单的形式中，共享工作空间可以被视为一个虚拟非结构化存储对象。 在更复杂的版本中，共享工作空间可以添加结构以为其用户创建单独的位置以进行编写，并且从Wiki到复杂的多用户分布式文件系统一直保持一致。 为了保持共享空间的一致视图，进程需要就空间上的写入和读取操作之间的相对顺序达成一致。

分布式数据库。 数据库构成了另一类应用程序，其中协议抽象有助于确保所有事务管理器获得正在运行的事务的一致视图，并可以就这些事务的序列化方式做出一致的决策。

另外，在决定事务的结果时，这种抽象可用于协调事务管理器。 也就是说，执行给定分布式事务的数据库服务器需要协调其活动并决定是提交还是中止事务。 如果任何数据库服务器检测到违反数据库完整性，并发控制不一致，磁盘错误或仅仅是某些其他数据库服务器崩溃，则他们可能决定中止事务。 正如我们所指出的，原子提交（或承诺）的分布式编程抽象提供了这种分布式协作。

#### 1.2.2 Distribution as an Artifact

通常，非本地分布的应用程序也使用来自分布式编程的复杂抽象。 这种需求有时表现为工程解决方案的工件，以满足某些特定要求，如容错，负载平衡或快速共享。

我们通过状态机复制来说明这一想法，这是在分布式系统中实现容错的一种强大方法。 简而言之，复制包括通过在假定独立失败的不同机器上执行多个副本来使集中式服务高度可用。 这确保了服务的连续性，尽管机器的子集失效。 不需要特定的硬件：通过复制实现的容错是基于软件的。 实际上，复制也可以在信息系统中使用，以通过将数据放置在可能被查询的进程附近来提高对数据的读访问性能。 例如，对于通过Internet受到攻击的服务，同样的方法也可以容忍恶意入侵，这些入侵会破坏提供服务的有限数量的复制节点。

要使复制生效，必须将不同的副本保持在一致状态。如果副本的状态可能任意分歧，那么谈论复制是没有意义的。一种高可用性服务的错觉将会崩溃，并被几种分布式服务的错觉所取代，每种服务都可能独立失败。如果副本是确定性的，保证完全一致性的最简单方法之一是确保所有副本以相同的顺序接收相同的请求集。通常，这种保证是通过称为全序广播的抽象来强制执行的：过程需要在此处就它们传递的消息序列达成一致。实现这种原语的算法是非常重要的，并且为程序员提供封装这些算法的抽象，使得复制服务的设计更容易。如果副本是不确定的，那么确保它们的一致性需要不同的排序抽象，我们将在本书的后面部分看到。实现这些抽象的挑战在于容忍可能影响副本的错误，这些错误可能包括简单的进程崩溃，也可能受到恶意攻击者的控制。

#### 1.3 The End-to-End Argument

分布式编程抽象是有用的，但实现起来有时可能很困难或昂贵。 在某些情况下，没有简单的算法能够提供所需的抽象，并且解决该问题的算法可能具有高复杂性，例如，在进程间通信步骤和消息的数量方面。 因此，根据系统模型，网络特性和所需的服务质量，抽象的开销可以从可忽略不计到几乎不可行。

面对性能限制，可以驱动应用程序设计者将抽象的相关逻辑与应用程序逻辑混合，以试图获得优化的集成解决方案。 理由通常是这样的解决方案应该比通过模块化方法获得的解决方案更好地执行，其中抽象被实现为可以通过明确定义的接口访问的独立服务。 这种方法可以通过对端到端论证的表面解释得到进一步支持：大多数复杂性应该在通信栈的更高层次上实现。 该参数可以应用于任何形式的（分布式）编程。

然而，即使在某些情况下通过折叠应用程序和底层来获得性能增益，这种单片方法也有许多缺点。 最重要的是，它容易出错。 本书中将介绍的一些算法具有相当大的难度，并且在其内部元素之间表现出微妙的依赖性。 明显的“优化”可能会破坏算法的正确性。 在这里引用Donald Knuth：

> “过早优化是万恶之源。”

即使设计人员达到了掌握在应用程序中嵌入这些算法的艰巨任务所需的专业知识，但还有其他几个原因可以使两个实现保持独立。 最引人注目的是，对于给定的分布式计算问题，通常没有单一的解决方案。 由于分布式系统模型的多样性，因此尤其如此。 相反，通常可以提出不同的解决方案，并且这些解决方案都不能严格优于其他解决方案：每个解决方案都有其自身的优点和缺点，在不同的网络或负载条件下表现更好，在网络流量和消息延迟之间进行不同的权衡 ， 等等。 依赖模块化方法允许在部署应用程序时选择最合适的实现，或者甚至允许在运行时在不同实现之间选择以响应环境的变化。

通过具有良好定义的接口的抽象来封装分布式交互的棘手问题，这有助于我们推断应用程序的正确性，并将其从一个系统移植到另一个系统。 我们坚信，在许多分布式应用程序中，特别是那些需要多对多交互的应用程序，使用多个抽象层构建分布式应用程序的初步原型可能非常有用。

最终，人们可能会考虑优化分布式应用程序最终版本的性能，并使用一些集成原型在一个单片代码中实现多个抽象。 但是，完全理解隔离的每个封闭抽象是确保组合代码正确性的基础。

### 1.4 Software Components

#### 1.4.1 Composition Model

符号。 在考虑描述分布式算法时，我们必须面对的最大困难之一是找到表示这些算法的适当方法。 当表示集中式算法时，可以决定使用编程语言，或者通过选择现有的流行算法，或者通过发明具有教学目的的新算法。

虽然确实已经有多次尝试提出分布式编程语言，但这些尝试已经产生了相当复杂的符号，这些符号在教学方式下用于描述通用分布式算法是不可行的。试图发明分布式编程语言不是一种选择。即使我们有时间成功地发明了一本书，也至少需要一本书来展示这门语言本身。

因此，我们选择使用伪代码来描述我们的算法。伪代码反映了反应计算模型，其中同一进程的组件通过交换事件进行通信：算法被描述为一组事件处理程序。这些对传入事件做出反应并可能触发新事件。事实上，伪代码非常接近我们在实验框架中编程算法的实际方式。基本上，算法描述可以看作是实际代码，我们从中删除了所有与实现相关的细节，这些细节比理解算法更有用。 这种方法有望简化那些有兴趣从本书中的描述构建运行原型的人的任务。

一个简单的例子。 抽象通常通过API表示。 我们将在这里非正式地讨论用于分布式编程抽象的简单示例API。

在整本书中，我们将使用基于异步事件的组合模型来描述API和算法。 每个进程都托管一组软件组件，在我们的上下文中称为模块。 每个组件都由一个名称标识，并由一组属性表征。 该组件以组件接受并生成的事件形式提供接口。 分布式编程抽象通常由用于满足一些共同属性的组件集合（每个过程至少一个）组成。

软件堆栈。 组件可以组成软件堆栈。 在每个过程中，组件表示堆栈中的特定层。 应用程序层位于堆栈的顶部，而网络层通常位于底部。 我们将考虑的分布式编程抽象层通常位于中间。 同一堆栈中的组件通过事件交换进行通信，如图1.1所示。 给定的抽象通常由一组组件实现，每个组件在一个进程中运行。

根据该模型，每个组件被构造为状态机，其转换由事件的接收触发。 事件可以在一个或多个属性中携带诸如数据消息或组成员资格信息的信息。 事件由`< EventType | Attributes ...>`表示。 通常，具有相同名称的事件由多个组件使用。 对于为组件`co`定义的事件，我们通常会写作：

>  <`co`, `EventType` | `Attributes`, . . . >

每个事件由该过程通过专用处理程序（即，由相应的组件）处理。根据事件引入的指令序列来表示处理程序，其描述事件，随后是具有要执行的指令的伪代码。事件的处理可能导致创建新事件并触发相同或不同的组件。如果进程正确，则最终处理由同一进程的组件触发的每个事件（除非目标模块明确过滤该事件;请参阅前面的这样的子句）。来自同一组件的事件按触发顺序处理。这种先进先出（FIFO）顺序仅对给定堆栈中本地组件之间交换的事件强制执行。不同进程之间的消息也可能需要根据某些标准进行排序，使用与此正交的机制。我们将在本书后面讨论这个进程间通信问题。

我们假设每个进程以互斥的方式执行事件触发的代码。 这意味着同一进程不会同时处理两个事件。 一旦事件的处理终止，该过程将继续检查是否触发了任何其他事件。 假定这种定期检查是公平的，并且以隐式方式实现：它在我们描述的伪代码中不可见。

由两个事件处理程序组成的示例组件`co1`的伪代码如下所示：

```
upon event < co1, Event1 | att11 , att21 , ... > do
	do something;
	trigger < co2 , Event2 | att12 , att22 >; // send some event
upon event < co1 , Event3 | att13 , att23 , ...> do
	do something else;
	trigger < co2 , Event4 | att14 , att24 , ...?; // send some other event
```

这种组件之间交互的解耦和异步方式非常符合分布式应用程序的要求：例如，新进程可以随时加入或离开分布式系统，并且进程必须准备好处理成员身份更改和消息接收 任何时候。 因此，不能先验地定义将观察到并发事件的顺序; 这正是我们通过组件模型捕获的内容。

对于编写复杂算法，我们有时会使用在实现中的某些条件变为真时触发的处理程序，但不响应源自另一个模块的外部事件。 内部事件的条件通常由算法维护的局部变量定义。 这样的处理程序包含一个on语句后跟一个条件; 在示例组件co中，它可能如下所示：

```
upon condition do			// an internal event
	do something;
```

由另一个模块的事件触发的on事件语句也可以使用局部变量的条件进行限定。 只有在外部事件被触发且条件成立时，此处理程序才会执行其指令。 组件co的这种条件事件处理程序具有以下形式：

```
upon event < co, Event | att11 , att21 , ... > such that condition do
	do something;
```

使用条件事件处理程序的算法依赖于运行时系统来缓冲外部事件，直到满足内部变量的条件。我们使用此约定是因为它简化了许多算法的表示，但不应将该方法作为实际实现实际系统的方法：这样的运行时系统可能需要维护无界缓冲区。但是，在实现中避免使用条件事件处理程序并不困难。一切 条件事件处理程序可以通过三个步骤转换为（纯）事件处理程序和内部事件的两个处理程序的组合：（1）引入一个局部变量，用于在外部事件发生时存储它，并安装由外部事件触发的事件处理程序没有任何条件的事件; （2）引入一个局部变量来存储内部变量的条件成为真; （3）添加一个本地事件处理程序，该处理程序响应内部事件，表示已发生外部事件并且已满足内部条件。

#### 1.4.2 Programming Interface

我们组件的API包括两类事件，`Request`和`indications`; 它们的详细语义取决于它们出现的组件：

- 组件使用`Request`事件来调用另一个组件上的服务或将条件发送到另一个组件。 例如，应用层可以在负责广播消息的组件上触发请求事件，该消息具有对组中的进程的一些可靠性保证，或者提出由组决定的值。 请求还可以携带信令信息，例如，当组件先前已经将一些数据输出到应用层并且该请求确认应用层已经处理了数据时。 从处理事件的组件的角度来看，请求事件是输入。
- `indications`事件由组件用于传递信息或向另一个组件发送信号。 考虑前面给出的广播示例，在作为消息目的地的每个进程中，负责实现实际广播原语的组件通常将执行一些处理以确保相应的可靠性保证，然后使用指示事件来传递消息。 到应用程序层。 同样，对这一事件也将表明对价值的决定。 指示事件还可以起到确认的作用，例如，当负责广播的组件向应用层指示消息确实是广播时。 从触发事件的组件的角度来看，指示事件是输出。

给定层的典型执行包括以下一系列动作，如图1.2所示。 我们在这里考虑一种广播抽象，它确保一定的可靠性条件，即一个原语，其中进程需要就是否传递某个进程广播的消息达成一致。

1. 通过从上面的层接收`Request`事件来发起用于发送广播消息的过程。
2. 为了确保广播抽象的属性，该层将通过调用下面层的服务（使用较低层的请求事件）向其远程对等体发送一个或多个消息。
3. 还使用底层的服务（通过下层的指示事件）接收由对等层发送的消息。
4. 当接收到消息时，可能必须临时存储消息，直到满足足够的可靠性属性，然后使用指示事件将其传送到上面的层。

请求和指示并不总是携带有效载荷数据; 它们还可以指示使两个层彼此同步的条件。 例如，广播抽象可以通过触发上面的层的专门指示事件来确认其服务已经可靠地结束。 以这种方式，广播实现可以要求应用层等待直到在触发下一个广播请求之前确认广播请求。 可以使用类似的机制来同步广播消息到上面的应用层的传送。 例如，当应用层花费很长时间来处理消息时，应用程序可以触发广播抽象的专门请求事件，以发信号通知处理已经完成，并且应用程序现在准备好传送下一个广播消息。

#### 1.4.3 Modules

毫不奇怪，本书中描述的大多数模块都与对等过程中的相应模块进行了一些交互; 毕竟，这是一本关于分布式计算的书。 但是，也可以使模块仅执行本地操作。 由于在一个进程的运行时系统中可能同时存在多个模块副本，因此模块的每个实例都由相应的标识符标识。

为了说明模块的概念，我们描述了一个简单的抽象作业处理程序模块。 应用程序可以向处理程序抽象提交作业，作业处理程序确认它已经负责处理作业。 模块1.1描述了它的接口。 作业处理程序确认每个提交的作业。 但是，接口明确地保持打开是否在确认到达时处理了作业。

> 模块1.1：作业处理程序的接口和属性

```
Module:
	Name: JobHandler, instance jh.
Events:
	Request: < jh, Submit | job >: Requests a job to be processed.
	Indication: < jh, Confirm | job >: Confirms that the given job has been (or will be)processed.
Properties:
	JH1: Guaranteed response: Every submitted job is eventually confirmed.
```

算法1.1是一个简单的作业处理程序实现，只有在处理完成后才能确认每个作业。此实现是同步的，因为提交作业的应用程序在处理作业时获知。 

> 算法1.1：同步作业处理程序

```
Implements:
	JobHandler, instance jh.
upon event < jh, Submit | job > do
	process(job);
	trigger < jh, Confirm | job > ;
```

算法1.2中给出了作业处理程序抽象的第二种实现。此实现是异步的，并立即确认每个提交的作业;它将作业保存在无限制的缓冲区中，并在后台以自己的速度处理缓冲的作业。 

> 算法1.2：异步作业处理程序

```
Implements:
	JobHandler, instance jh.
upon event < jh, Init > do
	buffer := ∅ ;
upon event < jh, Submit | job > do
	buffer := buffer ∪ { job } ;
	trigger < jh, Confirm | job > ;
upon buffer != ∅ do
	job := selectjob (buffer);
	process(job);
	buffer := buffer \ { job } ;
```



算法1.2说明了算法符号的两个特殊元素：初始化事件和内部事件。为了使组件的初始化显式化，我们假设在创建组件时运行时系统会自动生成一个特殊的`< Init >`事件。此事件可能会初始化组件使用的某些数据结构并执行某些设置操作。例如，在异步作业处理程序示例中，它用于创建空缓冲区。算法1.2的最后一个语句表示响应一个的事件处理程序 内部事件，如上一节所述。

为了演示如何组成模块，我们使用作业处理程序模块并通过在顶部添加图层的模块对其进行扩展; 图层可以在调用作业处理程序之前对作业应用任意转换。 两个模块的组成如图1.3所示。

 作业转换层的接口添加`<Error>`事件，该事件在转换失败时发生，但不会发生; 模块1.2中显示的界面。

算法1.3中给出了变换的一个例子。 该层实现了等待处理的有效长度的作业队列。 这些作业存储在长度为M的数组缓冲区中，该缓冲区初始化为⊥值的M向量，用[⊥] M表示。 顶部和底部的两个变量指向缓冲区，以便下一个到达的作业存储在索引顶部，下一个要删除的作业位于索引底部。 为了保持代码简单，这些变量是无界的整数，它们以模M的形式减少以访问数组。 该算法与底层作业处理程序同步交互，并在提交下一个作业之前等待，直到先前提交的作业得到确认。 当算法1.3与同步作业处理程序（算法1.1）结合使用时，运行时系统不需要任何无界缓冲区。

模块通常是静态实例化的; 这只发生一次，并且当另一个组件的实现在其使用的模块列表中包含该模块时隐式发生。 每个模块都有一个静态实例，可以由许多模块共享。 协议模块也可以使用先验未知数量的实例动态地实例化。 动态实例的初始化在调用它们的算法的代码中明确提到。

> 算法1.3：通过缓冲进行作业转换

本书中的所有模块抽象都是作为独立实例呈现的，以便简化其描述。 每个实例都有一个标识符。 当更高级别的算法调用更低级抽象的多个实例时，我们确保每个实例都由唯一标识符命名。 任何使用抽象的应用程序都应遵循相同的规则。

### 1.5 Classes of Algorithms

如前所述，为了提供特定服务，给定进程的层可能需要在远程进程处与对等层执行一轮或多轮消息交换。 每个对等体的行为，其特征在于它能够产生和接受的消息集，每个消息的格式以及消息的合法序列，有时被称为协议。 该协议的目的是确保一些分布式算法的执行，并行执行不同的步骤序列，以确保提供所需的服务。 本书涵盖了其中几种分布式算法。

为了让读者深入了解故障假设，环境，系统参数和其他设计选择如何影响算法设计，本书包含几种不同类型的算法解决方案来实现我们的分布式编程抽象，即：

1. 故障停止算法，假设进程可能因崩溃而失败，但崩溃可以被所有其他进程可靠地检测到;
2. 失败静默算法，永远无法可靠地检测到进程崩溃;
3. 故障噪声算法，其中进程可能因崩溃而失败，并且可以检测到崩溃，但并不总是以准确的方式检测到（精确度仅为最终）;
4. 故障恢复算法，其中进程可能崩溃并在以后恢复并仍然参与算法;
5. 失败任意算法，其中进程可以任意偏离协议规范并以恶意，对抗的方式行事;
6. 随机算法，除了目前提出的类之外，进程可以通过使用随机源进行概率选择。

这些类不是不相交的，重要的是要注意我们没有为每个抽象提供每个类的解决方案。 首先，有些情况下已知某些抽象无法通过给定类的算法实现。 例如，我们在第6章中考虑的一些协调抽象没有故障噪声（因而是故障 - 静默）解决方案，并且不清楚如何为这种抽象设计有意义的随机解决方案。 在其他情况下，可能存在这样的解决方案，但设计它们仍然是一个活跃的研究领域。

关于分布式算法的一般推理，特别是关于实现分布式编程抽象的算法的推理，首先涉及定义分布式系统的清晰模型，其中这些算法应该运行。 换句话说，我们需要弄清楚流程假设的基本抽象，以便构建更复杂的流程。 我们考虑的基本抽象捕获了分布式系统中进程及其通信链路的允许行为。 在深入研究具体算法以构建复杂的分布式编程抽象之前，我们需要理解这些基本的抽象。 这将是下一章的主题。

### 1.6 Chapter Notes

- 使用多个复制过程来容忍各个进程的错误的想法将本书中介绍的大多数算法联系在一起。 这种模式可以追溯到1978年软件实施的容错（SIFT）项目的工作，该项目解决了构建 用于飞机控制的容错计算机（Wensley等，1978）。
- 原子提交问题是由Gray（1978）在分布式数据库的背景下提出的。 后来Skeen（1981）引入了一个问题的变体，确保了活力。 我们在第6章中描述了非阻塞原子提交问题。
- 端到端的论证是由Saltzer，Reed和Clark（1984）提出的。
- Schneider（1990）的一项调查描述了状态机复制及其关系总序广播。 第6章详细讨论了这两个主题。























