## Preface

本书介绍了分布式编程抽象，并介绍了在几个分布式环境中实现它们的基本算法。 读者可以深入了解分布式计算的重要问题以及用于解决这些问题的主要算法技术。 通过示例，读者可以了解如何将这些方法应用于构建分布式应用程序。 本书的核心主题是对分布式系统中的不确定性和对抗性影响的容忍度，这可能是由网络延迟，故障甚至恶意攻击引起的。

## Content

在现代计算中，程序通常包含多个过程。 进程只是一种抽象，它可能是物理计算机或虚拟计算机，计算机内的处理器或并发系统中的特定执行线程。 设计这种分布式程序的根本问题是让所有进程在一些共同任务上合作。 当然，传统的中心化算法问题仍需要针对每个流程单独处理。 分布式环境可能从单个计算机到数据中心甚至是全天候可用的全球系统，这带来了额外的挑战：如何在流程失败，某些流程断开甚至恶意的情况下实现强大的合作形式 攻击某些进程？ （how to achieve a robust form of cooperation despite process failures, disconnections of some of the processes, or even malicious attacks on some processes?）分布式算法应该是可靠的，提供可靠性和安全性，并且具有可预测性 甚至在环境的负面影响下的行为。

如果不需要合作，分布式程序将只包含一组独立的集中式程序，每个程序都在特定的进程上运行，并且可以从分布式环境中的多个进程的可用性中获得很少的好处。 需要合作才能揭示本书所涉及的许多引人入胜的问题，需要解决的问题才能使分布式计算成为现实。 本书不仅向读者介绍了这些问题陈述，还介绍了在不同背景下解决这些问题的方法。

毫不奇怪，如果强健合作的难度被封装在特定的抽象中，则可以大大简化分布式编程。 通过封装所有棘手的算法问题，这种分布式编程抽象弥合了网络通信层之间的差距，网络通信层在可靠性保证方面通常是节俭的，而分布式应用层通常需要高度可靠的原语。

本书介绍了各种分布式编程抽象，并描述了实现它们的算法。 从某种意义上说，我们为分布式应用程序编程人员提供了一个抽象接口规范库，并为分布式系统构建器提供了实现规范的算法库。

本书的大量准备时间用于制定一系列练习并开发其解决方案。 我们强烈建议读者进行练习。 我们认为，不能以被动的方式实现合理的理解。 在分布式计算领域尤其如此，人类思维经常遵循一些有吸引力但误导性的直觉。 本书还包括所有练习的解决方案，以强调我们打算将它们作为内容的组成部分。 许多练习相当容易，可以在本科教学课堂上讨论。 其他练习更难，需要更多时间。 这些通常可以单独研究。

## Presentation

这本书是独立的。 这已经成为可能，因为分布式算法领域已经达到了一定程度的成熟度，其中可以抽象出分散的细节以推断分布式算法。 这些细节包括通信网络的行为，其各种故障，以及加密边缘的实现; 所有这些都被其他作品深入对待。 关于算法，一阶逻辑，编程语言，网络，安全性和操作系统的基本知识可能会有所帮助。 但我们相信，大多数抽象和算法都可以通过对这些概念知之甚少来理解。

本书遵循渐进式方法，主要是作为本科或基础研究生教学的教科书编写的。 它以直观的方式介绍了分布式计算的基本元素，并以模块化方式从基本元素构建复杂的分布式编程抽象。 每当我们设计算法来实现给定的抽象时，我们首先考虑一个简单的分布式系统模型，然后我们在更具挑战性的模型中重新审视算法。 换句话说，我们首先通过对分布式环境进行强有力的简化假设来设计算法，然后讨论如何削弱这些假设。

我们一方面试图平衡直觉和表现简洁，另一方面又要求严谨。 有时严苛会受到影响，而这可能并不总是故意的。 这里的重点是抽象规范和算法，而不是可计算性和复杂性。 实际上，本书中没有定理。 为了更好地理解算法，给出了正确性论证：它们本身并不是正式的正确性证明。

## Organization

这本书有六章，分为两部分。 第一部分确立了共同点：

- 在第1章中，我们通过讨论通常利用这种抽象的各种应用来激发对分布式编程抽象的需求。 本章还介绍了模块化符号和用于描述本书算法的伪代码。
- 在第2章中，我们提出了有关底层分布式环境的各种假设。 为此，我们引入了一系列分布式系统模型。 基本上，模型描述了构建更复杂的抽象的低级抽象。 这些包括进程和通信链接抽象。 本章可能被视为对其他章节的参考。

其余四章构成了本书的第二部分。 每一章都专门讨论一个问题，包含一大类相关的抽象和实现它们的各种算法。 我们将从更简单的抽象转向更复杂的抽象：

- 在第3章中，我们介绍了分布式编程的通信抽象。 它们允许向一组进程广播消息，并提供各种可靠性保证，以便向进程传递消息。 例如，我们讨论了如何确保传递给一个进程的消息也被传递给所有其他进程，尽管原始发送者进程崩溃了。
- 在第4章中，我们讨论了共享内存抽象，它封装了通过读写操作访问的简单形式的分布式存储对象。 这些可以是分布式存储系统中的文件，也可以是多处理器计算机的存储器中的寄存器。 我们将介绍客户端读取和写入数据值的方法，以便稍后可以检索由一组进程存储的值，即使某些进程崩溃，已擦除值或报告错误数据。
- 在第5章中，我们讨论了一致性抽象，通过这种抽象，一组进程可以根据进程最初提出的值来决定一个公共值。 尽管有错误的过程，他们必须做出同样的决定，这些过程可能已经崩溃，甚至可能会积极地试图阻止其他人做出共同的决定。
- 在第6章中，我们考虑共识的变体，这些变体是通过根据重要应用的需要扩展或修改共识抽象而获得的。 这包括总顺序广播，发送可靠广播，（非阻塞）原子提交，组成员资格和视图同步通信。

我们研究的分布式算法不仅根据它们实现的实际抽象而不同，而且还根据它们对底层分布式环境的假设而不同。 我们将一组初始抽象称为算法理所当然的分布式系统模型。 许多方面对如何设计算法具有根本性影响，例如链路的可靠性，系统的同步程度，故障的严重性以及是否寻求确定性或随机化解决方案。

在本书的几个地方，在多个分布式系统模型中实现了相同的基本分布式编程原语。 这背后的意图有两方面：第一，创建对特定系统模型中遇到的特定问题的洞察，其次，说明模型的选择如何影响的原语实现。

对所有章节和相关练习的详细研究构成了对该领域的丰富而全面的介绍。 仅关注抽象的规范及其最简单形式的基础算法，即仅针对具有崩溃故障的最简单系统模型，将构成更短，更基础的过程。 这样的课程可以为更加注重实践的分布式编程课程提供一个很好的伴侣。

## Changes Made for the Second Edition

此版本是第一版的彻底修订版。 本书的大部分内容都已更新。 但最大的变化是将本书的范围扩展到一个新的层面，解决了针对恶意行为的安全性的关键概念。 允许对抗性攻击的分布式计算模型中的抽象和算法已被称为拜占庭容错。

本书的第一版标题为“可靠的分布式编程简介”。通过在标题中添加一个词（“安全”） - 并添加一个共同作者 - 本书的演变反映了分布式系统领域的发展。在现实世界中。自从第一版于2006年出版以来，很明显大多数实际的分布式系统都受到入侵的威胁，并且内部人员不能被排除为恶意攻击的来源。如今构建可靠的分布式系统需要跨学科的努力，来自分布式算法，安全性和其他领域的输入。

在技术层面上，模块的语法和某些事件的名称已经改变，以便添加更多用于呈现算法的结构。一个模块 现在可以在算法中同时存在于多个实例中，并且为此目的，每个实例都由唯一标识符命名。我们相信这简化了几种重要算法的呈现。

 本书的第一版包含使用Appia协议组合框架在Java编程语言中实现的一组运行示例。该实现解决了崩溃失败的系统，可从该书的在线网站获得。

## References

我们近二十年来一直在探索分布式编程抽象的世界。本书的内容受到分布式计算领域许多研究人员的影响。值得一提的是Leslie Lamport和Nancy Lynch在分布式计算和康奈尔大学的可靠分布式计算方面提出了令人着迷的问题，包括ÖzalpBabaoglu，Ken Birman，Keith Marzullo，Robbert van Rennesse，Rick Schlichting，Fred Schneider和Sam Toueg。

许多其他研究人员直接或间接地启发了本书的内容。我们尽力在整篇文章中提及他们的工作。所有章节 以提供背景信息和历史参考的注释结束;我们背后的意图是提供进一步阅读的提示，追踪所呈现概念的历史，以及对发明和制定概念的人们给予信任。在本书的最后，我们参考了有关分布式计算其他方面的书籍以供进一步阅读。

